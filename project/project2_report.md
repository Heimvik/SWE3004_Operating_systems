# CFS Scheduler
Name: Christian Magnus Engebretsen Heimvik
Kingo ID: 2025318314

## How scheduling works in XV6 today
The scheduling on the XV6 before my implementation operated with 3 "levels". First of all; all the way down is the user process. The context we have here can be regarded as the lowest level.

Whenever a timer tick happns we get a timer interrupt which is catched by the IDT (as explained in the previous report), corresponding vector in vectors.S gets executed, which after a detour through trapasm with the _jmp alltraps_ label and the building of the trapframe, we end up in trap.c when the instruction _call trap_ is executed in trapasm.S. Here, the kernel of process A calls yield() with this code whenever it's time is up.
```C
  if(myproc() && myproc()->state == RUNNING &&
     tf->trapno == T_IRQ0+IRQ_TIMER)
    yield();
```
This call to yield is somewhat special as we now will change the execution i
locking table
to sched
------at swtch in shed() proc A -> this switches stack and instruction code from kernel A to scheduler context
enter scheduler() at swtch() (magic wtf)
changes the process to run to the next on in the pt (which we have locked still(process independent))
exit scheduler at switch()
------at swtch in shed() proc B -> this switches stack and instruction code back to kernel B as nothing happend
in sched
unlocking table

*Effectively means that it runs the next one for one tick*
Wow, thats cool.

Considerations:
- Note that great parts (all) of the scheduler itself lies in scheduler()
- The only thing: in trap.c does each kernel thread seem to yield() vaulentarily. That is, it calls yield EVERY clock tick generated by the int timer. However this is what we want, but the thing is is that in the current implementation, exe does NOT return eaxh clock tick, but here we will.

The code from trap.c all above happens each clock tick!

## How the CFS scheduler works
The Completely Fair scheduler (CFS) is a CPU scheduling algorithm that aims to provide fair CPU time to all processes in the system, but also taking priorities into account. Each process has 3 major variables that determine its behaviour in the scheduler:
- **weight**: The weight of a process is calculated as the inverse of its niceness. The nicess, the lower the weight. The weight is hard coded due to its constant nature and given as an array, indexed by its corresponding niceness. The array of weights was generated by a simple python script and is defined as follows:
```C
static const int cfs_weights[40] = {
    88818,     71054,     56843,     45475,     36380,
    29104,     23283,     18626,     14901,     11921,
    9537,     7629,     6104,     4883,     3906,
    3125,     2500,     2000,     1600,     1280,
    1024,     819,     655,     524,     419,
    336,     268,     215,     172,     137,
    110,     88,     70,     56,     45,
    36,     29,     23,     18,     15,
};

```

- **vruntime**: A variable that accumulates when the process is running, and it tracks the "effective" amount of time a process has been running, accordng to its priority. The vruntime for a given process needs to be updated after every time it has run, and the increment in vruntime of a given process p after each run is
$$ \text{p->vruntime} += \text{p->vruntime}\frac{\text{weights}[20]}{\text{p->weight}}$$
- **timeslice**: The timeslice a process is allowed to run before has to yield. It must in all cases be larger than sched_granularity. The timeslice has to be calculated the when having picked the next one based of the vruntime of the processes, and before the process is set to RUNNING state by the following formula, where 10 is out sched_latency or our ticks:
$$ \text{p->timeslice} = \text{10} + \frac{\text{p->weight}}{\sum_i \text{p[i]->runnable ? p[i]->weight : 0}}$$

The CFS scheduler will then schedule the processes as follows:
1. Pick the process with the lowest vruntime from ready processes.
2. Calculate the timeslice for the process according to the equation above.
3. Set the process to RUNNING state.
4. When done running, update the vruntime of the process according to the equation above.
5. If not done, set the process state to RUNNABLE. Else indicate finsihed. 
6. Go to step 1.
